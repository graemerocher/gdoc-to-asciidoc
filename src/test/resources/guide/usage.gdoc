The cache plugin adds Spring bean method call, controller action, and GSP page fragment and template caching to Grails applications. You configure one or more caches in @Config.groovy@ and/or one or more Groovy artifact files with names ending in CacheConfig.groovy (for example FooCacheConfig.groovy, BarCacheConfig.groovy, and these can also be in packages) in @grails-app/conf@ (or a subdirectory if in a package) using an implementation-specific DSL, and annotate methods (either in Spring beans (typically Grails services) or controllers) to be cached. You can also wrap GSP sections in cache tags and render cached templates.

There are three annotations; [Cacheable|api:grails.plugin.cache.Cacheable], [CachePut|api:grails.plugin.cache.CachePut], and [CacheEvict|api:grails.plugin.cache.CacheEvict]. You use \@Cacheable to mark a method as one that should check the cache for a pre-existing result, or generate a new result and cache it. Use \@CachePut to mark a method as one that should always be evaluated and store its result in the cache regardless of existing cache values. And use \@CacheEvict to flush a cache (either fully or partially) to force the re-evaluation of previously cached results. The annotations are based on the annotations with the same name from Spring ([Cacheable|http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/annotation/Cacheable.html], [CachePut|http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/annotation/CachePut.html], and [CacheEvict|http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/
springframework/cache/annotation/CacheEvict.html]) and support the same syntax but may support extended functionality in the future.

When using distributed caching (such as ehcache with distributed cache enabled, or redis with multiple instances of the application running against one redis instance), all classes that use annotation caching or XML caching should override the @hashCode@ method. The hash code of the object with the method marked as being cacheable is included in the cache key, and the default @hashCode@ implementation will vary each time the application is run. Overriding @hashCode@ ensures that each instance of the applications will appropriately share cache keys.

This 'core' cache plugin uses an in-memory implementation where the caches and cache manager are backed by a thread-safe @java.util.concurrent.ConcurrentMap@. This is fine for testing and possibly for low-traffic sites, but you should consider using one of the extension plugins if you need clustering, disk storage, persistence between restarts, and more configurability of features like time-to-live, maximum cache size, etc. Currently the extension plugins include [cache-ehcache|http://grails.org/plugin/cache-ehcache], [cache-redis|http://grails.org/plugin/cache-redis], and [cache-gemfire|http://grails.org/plugin/cache-gemfire].
